<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style type="text/css">
        .axis path,
        .axis line {
            fill: none;
            stroke: black;
        }
        .axis text {
            font-family: sans-serif;
            font-size: 12px;
        }
        .node {
            stroke: #fff;
        }
        .label {
          font: 16px sans-serif;
          pointer-events: none;
        }
        .tooltipMap {
        text-align: center;
        color: white;
        font-weight: bold;
         }

        .rect {
        
            transition: fill 0.2s; 
            }
        .rect:hover {
                fill: #C8A2C8;
            }
            

    </style>
</head>
<body>
    <script type="module">
        import * as d3 from "https://cdn.jsdelivr.net/npm/d3@7/+esm";

        const NetflixData = (callback) => {
        d3.csv("netflix_titles.csv").then((data) => {
        let dataset = data
            .filter(d => d.director && d.director.trim() !== "")    
            .filter(d => d.rating && d.rating.trim() !== "")            
            .flatMap((d) => {
                const countries = d.country.split(',').map(country => country.trim());
                return countries.map(country => ({
                    type: d.type,
                    title: d.title,
                    director: d.director,
                    cast: d.cast,
                    country: country, 
                    date_added: d.date_added,
                    release_year: d.release_year,
                    rating: d.rating,
                    duration: d.duration,
                    listed_in: d.listed_in,
                    description: d.description,
                }));
                        }); 
        callback(dataset);
    });      
};


function visualizeDurationCountsHistogram(data) {
    
    let h = 500;
    let w = 600;
    let padding = 50;

    let svg = d3.select("body")
                .append("svg")
                .attr("height", h + 70)
                .attr("width", w);


    //***Duration/Counts Histogram***//
    let durationCounts = d3.rollup(data, v => v.length, d => d.duration);

     let sortedDurations = Array.from(durationCounts.entries())
                .sort((a, b) => b[1] - a[1])
                .slice(0, 15); // Top15

    let xScale = d3.scaleBand()
        // .domain(Array.from(durationCounts.keys()))
        .domain(sortedDurations.map(d => d[0]))
        .range([padding, w - padding])
        .padding(0.1);

    let maxCountDurations = d3.max(sortedDurations, d => d[1])

    let yScale = d3.scaleLinear()
        //.domain([0, d3.max(durationCounts.values())])
        .domain([0,maxCountDurations + 0.05*maxCountDurations ])
        .range([h - padding, padding]);

    let bars = svg.selectAll("rect")   
                .data(sortedDurations)
                .enter()
                .append("rect")
                .attr("x", d => xScale(d[0]))
                .attr("y", d => yScale(d[1]))
                .attr("width", xScale.bandwidth())
                .attr("height", d => h - padding - yScale(d[1]))
                .attr("fill", "purple");


    let labels = svg.selectAll("text")
                    .data(sortedDurations)
                    .enter()
                    .append("text")
                    .text(d => d[1]) 
                    .attr("x", d => xScale(d[0]) + xScale.bandwidth() / 2)
                    .attr("y", d => yScale(d[1]) - 5) 
                    .attr("text-anchor", "middle")
                    .attr("font-family", "sans-serif")
                    .attr("font-size", "12px")
                    .attr("font-weight", "700") 
                    .attr("fill", "black")
                    .style("opacity", 0);
                    

    bars.on("mouseover", function (event, d) {
        d3.select(this).attr("fill", "orange"); 
        labels.filter(label => label === d)
            .style("opacity", 1); 
    })
        .on("mouseout", function (event, d) {
            d3.select(this).attr("fill", "purple"); 
            labels.filter(label => label === d)
                .style("opacity", 0); 
        });

    svg.append("g")
        .attr("transform", "translate(0," + (h - padding) + ")")
        .call(d3.axisBottom(xScale))
        .selectAll("text")
        .style("text-anchor", "end")
        .attr("font-weight", 600)
        .attr("dx", "-.8em")
        .attr("dy", ".15em")
        .attr("transform", "rotate(-45)");

    svg.append("g")
        .attr("transform", "translate(" + padding + ",0)")
        .call(d3.axisLeft(yScale))
        .selectAll("text")
        .attr("font-weight", 600);

    svg.append("text")
        .attr("x", w / 2)
        .attr("y", h + 60 )
        .attr("text-anchor", "middle")
        .attr("font-family", "sans-serif")
        .attr("font-size", "16px")
        .attr("font-weight", "bold")
        .text("Highest 15 Shows & movies Duration Counts");
}

function visualizeDateAddedCountsHistogram(data) {
    
    let h = 500;
    let w = 600;
    let padding = 50;

    let svg = d3.select("body")
                .append("svg")
                .attr("height", h + 70)
                .attr("width", w);



    //***Date_Added/Counts Histogram***//

    let dateAddedCounts = d3.rollup(data, v => v.length, d => d.date_added);

    let sortedDateAdded = Array.from(dateAddedCounts.keys()).sort((a, b) => b - a);

    let last15DateAdded = sortedDateAdded.slice(0, 15);

    let xScaleDateAdded = d3.scaleBand()
        .domain(last15DateAdded)
        .range([padding, w - padding])
        .padding(0.1);

    let maxDateAddedCounts = d3.max(last15DateAdded.map(year => dateAddedCounts.get(year))) || 0;

    let yScaleDateAdded = d3.scaleLinear()
        .domain([0, maxDateAddedCounts + 0.05 * maxDateAddedCounts])
        .range([h - padding, padding]);

    svg.selectAll(".date-added-rect")
        .data(last15DateAdded.map(year => [year, dateAddedCounts.get(year)]))
        .enter()
        .append("rect")
        .attr("class", "date-added-rect")
        .attr("x", d => xScaleDateAdded(d[0]))
        .attr("y", d => h - padding)
        .attr("width", xScaleDateAdded.bandwidth())
        .attr("height", 0) 
        .attr("fill", "purple")
        .transition() 
        .duration(1000) 
        .attr("y", d => yScaleDateAdded(d[1]))
        .attr("height", d => h - padding - yScaleDateAdded(d[1]));

    svg.selectAll(".date-added-label")
        .data(last15DateAdded.map(year => [year, dateAddedCounts.get(year)]))
        .enter()
        .append("text")
        .attr("class", "date-added-label")
        .text(d => d[1])
        .attr("x", d => xScaleDateAdded(d[0]) + xScaleDateAdded.bandwidth() / 2)
        .attr("y", d => yScaleDateAdded(d[1]) - 5)
        .attr("text-anchor", "middle")
        .attr("font-family", "sans-serif")
        .attr("font-size", "12px")
        .attr("font-weight", "700")
        .attr("fill", "black")
        .style("opacity", 0);

    svg.selectAll(".date-added-rect")
        .on("mouseenter", function (event, d) {
            d3.select(this).attr("fill", "orange");
            svg.selectAll(".date-added-label")
                .filter(label => label[0] === d[0])
                .style("opacity", 1);
        })
        .on("mouseleave", function (event, d) {
            d3.select(this).attr("fill", "purple");
            svg.selectAll(".date-added-label")
                .filter(label => label[0] === d[0])
                .style("opacity", 0);
        });

    svg.append("g")
        .attr("transform", "translate(0," + (h - padding) + ")")
        .call(d3.axisBottom(xScaleDateAdded))
        .selectAll("text")
        .style("text-anchor", "end")
        .attr("font-weight", 600)
        .attr("dx", "-.8em")
        .attr("dy", ".15em")
        .attr("transform", "rotate(-45)");

    svg.append("g")
        .attr("transform", "translate(" + padding + ",0)")
        .call(d3.axisLeft(yScaleDateAdded))
        .selectAll("text")
        .attr("font-weight", 600);
    
    svg.append("text")
        .attr("x", w / 2)
        .attr("y", h + 60 ) 
        .attr("text-anchor", "middle")
        .attr("font-family", "sans-serif")
        .attr("font-size", "16px")
        .attr("font-weight", "bold")
        .text("Last 15 date added Counts");
}

function visualizeReleaseYearCountsHistogram(data) {

    let h = 500;
    let w = 600;
    let padding = 50;

    let svg = d3.select("body")
                .append("svg")
                .attr("height", h + 70)
                .attr("width", w);



    //***Release_year/Counts Histogram***//

    let releaseYearCounts = d3.rollup(data, v => v.length, d => d.release_year);

    let sortedReleaseYears = Array.from(releaseYearCounts.keys()).sort((a, b) => b - a);

    let last15ReleaseYears = sortedReleaseYears.slice(0, 15);

    let xScaleReleaseYear = d3.scaleBand()
        .domain(last15ReleaseYears)
        .range([padding, w - padding])
        .padding(0.1);

    let maxReleaseYearCounts = d3.max(last15ReleaseYears.map(year => releaseYearCounts.get(year))) || 0;

    let yScaleReleaseYear = d3.scaleLinear()
        .domain([0, maxReleaseYearCounts + 0.05 * maxReleaseYearCounts])
        .range([h - padding, padding]);

    svg.selectAll(".release-year-rect")
        .data(last15ReleaseYears.map(year => [year, releaseYearCounts.get(year)]))
        .enter()
        .append("rect")
        .attr("class", "release-year-rect")
        .attr("x", d => xScaleReleaseYear(d[0]))
        .attr("y", d => h - padding)
        .attr("width", xScaleReleaseYear.bandwidth())
        .attr("height", 0) 
        .attr("fill", "steelblue")
        .transition() 
        .duration(1000) 
        .attr("y", d => yScaleReleaseYear(d[1]))
        .attr("height", d => h - padding - yScaleReleaseYear(d[1]));

    svg.selectAll(".release-year-label")
        .data(last15ReleaseYears.map(year => [year, releaseYearCounts.get(year)]))
        .enter()
        .append("text")
        .attr("class", "release-year-label")
        .text(d => d[1])
        .attr("x", d => xScaleReleaseYear(d[0]) + xScaleReleaseYear.bandwidth() / 2)
        .attr("y", d => yScaleReleaseYear(d[1]) - 5)
        .attr("text-anchor", "middle")
        .attr("font-family", "sans-serif")
        .attr("font-size", "12px")
        .attr("font-weight", "700")
        .attr("fill", "black")
        .style("opacity", 0);

    svg.selectAll(".release-year-rect")
        .on("mouseenter", function (event, d) {
            d3.select(this).attr("fill", "orange");
            svg.selectAll(".release-year-label")
                .filter(label => label[0] === d[0])
                .style("opacity", 1);
        })
        .on("mouseleave", function (event, d) {
            d3.select(this).attr("fill", "steelblue");
            svg.selectAll(".release-year-label")
                .filter(label => label[0] === d[0])
                .style("opacity", 0);
        });

    svg.append("g")
        .attr("transform", "translate(0," + (h - padding) + ")")
        .call(d3.axisBottom(xScaleReleaseYear))
        .selectAll("text")
        .style("text-anchor", "end")
        .attr("font-weight", 600)
        .attr("dx", "-.8em")
        .attr("dy", ".15em")
        .attr("transform", "rotate(-45)");

    svg.append("g")
        .attr("transform", "translate(" + padding + ",0)")
        .call(d3.axisLeft(yScaleReleaseYear))
        .selectAll("text")
        .attr("font-weight", 600);
    
    svg.append("text")
        .attr("x", w / 2)
        .attr("y", h + 60) 
        .attr("text-anchor", "middle")
        .attr("font-family", "sans-serif")
        .attr("font-size", "16px")
        .attr("font-weight", "bold")
        .text("Last 15 Years Release Year Counts");
}

function visualizeRatingCountsHistogram(data){
    let h = 500;
    let w = 600;


    let svg = d3.select("body")
        .append("svg")
        .attr("height", h + 70)
        .attr("width", w);

    let padding = 50;

    //***Rating/Counts Histogram***//

    let ratingCounts = d3.rollup(data, v => v.length, d => d.rating);

    let sortedRatings = Array.from(ratingCounts.keys()).sort();

    let xScaleRating = d3.scaleBand()
        .domain(sortedRatings)
        .range([padding, w - padding])
        .padding(0.1);

    let maxRatingCounts = d3.max(sortedRatings.map(rating => ratingCounts.get(rating))) || 0;

    let yScaleRating = d3.scaleLinear()
        .domain([0, maxRatingCounts + 0.05 * maxRatingCounts])
        .range([h - padding, padding]);

    svg.selectAll(".rating-rect")
        .data(sortedRatings.map(rating => [rating, ratingCounts.get(rating)]))
        .enter()
        .append("rect")
        .attr("class", "rating-rect")
        .attr("x", d => xScaleRating(d[0]))
        .attr("y", d => h - padding)
        .attr("width", xScaleRating.bandwidth())
        .attr("height", 0) 
        .attr("fill", "green")
        .transition() 
        .duration(1000) 
        .attr("y", d => yScaleRating(d[1]))
        .attr("height", d => h - padding - yScaleRating(d[1]));

    svg.selectAll(".rating-label")
        .data(sortedRatings.map(rating => [rating, ratingCounts.get(rating)]))
        .enter()
        .append("text")
        .attr("class", "rating-label")
        .text(d => d[1])
        .attr("x", d => xScaleRating(d[0]) + xScaleRating.bandwidth() / 2)
        .attr("y", d => yScaleRating(d[1]) - 5)
        .attr("text-anchor", "middle")
        .attr("font-family", "sans-serif")
        .attr("font-size", "12px")
        .attr("font-weight", "700")
        .attr("fill", "black")
        .style("opacity", 0);

    svg.selectAll(".rating-rect")
        .on("mouseenter", function (event, d) {
            d3.select(this).attr("fill", "orange");
            svg.selectAll(".rating-label")
                .filter(label => label[0] === d[0])
                .style("opacity", 1);
        })
        .on("mouseleave", function (event, d) {
            d3.select(this).attr("fill", "green");
            svg.selectAll(".rating-label")
                .filter(label => label[0] === d[0])
                .style("opacity", 0);
        });

   
    svg.append("g")
        .attr("transform", "translate(0," + (h - padding) + ")")
        .call(d3.axisBottom(xScaleRating))
        .selectAll("text")
        .style("text-anchor", "end")
        .attr("font-weight", 600)
        .attr("dx", "-.8em")
        .attr("dy", ".15em")
        .attr("transform", "rotate(-45)")
        .attr("font-size", "10px"); 

    svg.append("g")
        .attr("transform", "translate(" + padding + ",0)")
        .call(d3.axisLeft(yScaleRating))
        .selectAll("text")
        .attr("font-weight", 600);

    svg.append("text")
        .attr("x", w / 2)
        .attr("y", h + 60)
        .attr("text-anchor", "middle")
        .attr("font-family", "sans-serif")
        .attr("font-size", "16px")
        .attr("font-weight", "bold")
        .text("All Ratings Counts");
}

function visualizeTopDirectorsHistogram(data) {
    let h = 500;
    let w = 600;

    let svg = d3.select("body")
        .append("svg")
        .attr("height", h + 70) 
        .attr("width", w);

    let padding = 50;

    //***Top Directors/Title Counts Histogram***//
 
    let directorCounts = {};

    data.forEach(d => {
        let directors = d.director.split(/\s*,\s*/);
        directors.forEach(dir => {
            if (directorCounts[dir]) {
                directorCounts[dir]++;
            } else {
                directorCounts[dir] = 1;
            }
        });
    });

    let sortedDirectors = Object.entries(directorCounts)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 15);

    let xScaleDirectors = d3.scaleBand()
        .domain(sortedDirectors.map(d => d[0]))
        .range([padding, w - padding])
        .padding(0.1);

    let maxDirectorCounts = d3.max(sortedDirectors, d => d[1]) || 0;

    let yScaleDirectors = d3.scaleLinear()
        .domain([0, maxDirectorCounts + 0.05 * maxDirectorCounts])
        .range([h - padding, padding]);

    svg.selectAll(".director-rect")
        .data(sortedDirectors)
        .enter()
        .append("rect")
        .attr("class", "director-rect")
        .attr("x", d => xScaleDirectors(d[0]))
        .attr("y", d => h - padding)
        .attr("width", xScaleDirectors.bandwidth())
        .attr("height", 0)
        .attr("fill", "blue")
        .transition()
        .duration(1000)
        .attr("y", d => yScaleDirectors(d[1]))
        .attr("height", d => h - padding - yScaleDirectors(d[1]));

    svg.selectAll(".director-label")
        .data(sortedDirectors)
        .enter()
        .append("text")
        .attr("class", "director-label")
        .text(d => d[1])
        .attr("x", d => xScaleDirectors(d[0]) + xScaleDirectors.bandwidth() / 2)
        .attr("y", d => yScaleDirectors(d[1]) - 5)
        .attr("text-anchor", "middle")
        .attr("font-family", "sans-serif")
        .attr("font-size", "12px")
        .attr("font-weight", "700")
        .attr("fill", "black")
        .style("opacity", 0);

    svg.selectAll(".director-rect")
        .on("mouseenter", function (event, d) {
            d3.select(this).attr("fill", "orange");
            svg.selectAll(".director-label")
                .filter(label => label === d)
                .style("opacity", 1);
        })
        .on("mouseleave", function (event, d) {
            d3.select(this).attr("fill", "blue");
            svg.selectAll(".director-label")
                .filter(label => label === d)
                .style("opacity", 0);
        });

    svg.append("g")
        .attr("transform", "translate(0," + (h - padding) + ")")
        .call(d3.axisBottom(xScaleDirectors))
        .selectAll("text")
        .style("text-anchor", "end")
        .attr("font-weight", 600)
        .attr("dx", "-.8em")
        .attr("dy", ".15em")
        .attr("transform", "rotate(-45)")
        .attr("font-size", "10px");

    svg.append("g")
        .attr("transform", "translate(" + padding + ",0)")
        .call(d3.axisLeft(yScaleDirectors))
        .selectAll("text")
        .attr("font-weight", 600);

    svg.append("text")
        .attr("x", w / 2)
        .attr("y", h + 60)
        .attr("text-anchor", "middle")
        .attr("font-family", "sans-serif")
        .attr("font-size", "16px")
        .attr("font-weight", "bold")
        .text("Top 15 Directors by Title Counts");
}

function visualizeRatingPieChart(data) {

    let ratingCounts = d3.rollup(data, v => v.length, d => d.rating);

    let pieData = Array.from(ratingCounts, ([rating, count]) => ({ rating, count }));

    pieData.sort((a, b) => b.count - a.count);

    let top5Data = pieData.slice(0, 5);
    let othersCount = d3.sum(pieData.slice(5), d => d.count);
    top5Data.push({ rating: "Others", count: othersCount });

    let totalCount = d3.sum(top5Data, d => d.count);
    top5Data.forEach(d => {
        d.percentage = (d.count / totalCount) * 100;
    });

    let width = 700;
    let height = 500;
    let radius = Math.min(width, height) / 2.5;

    let color = d3.scaleOrdinal(d3.schemeCategory10);

    let svg = d3.select("body")
        .append("svg")
        .attr("width", width+ 100)
        .attr("height", height + 100)
        .append("g")
        .attr("transform", "translate(" + width / 2 + "," + height / 2 + ")");

    let pie = d3.pie()
        .value(d => d.percentage);

    let arc = d3.arc()
        .outerRadius(radius - 10)
        .innerRadius(0);

    let arcs = svg.selectAll(".arc")
        .data(pie(top5Data))
        .enter()
        .append("g")
        .attr("class", "arc");

    arcs.append("path")
        .attr("d", arc)
        .attr("fill", d => color(d.data.rating));

    arcs.append("text")
        .attr("transform", d => "translate(" + arc.centroid(d) + ")")
        .attr("dy", ".25em")
        .text(d => `${d.data.percentage.toFixed(1)}%`)        
        .attr("font-family", "sans-serif")
        .style("font-weight", "600")
        .style("text-anchor", "middle");

    svg.append("text")
        .attr("x", 0)
        .attr("y", height / 2 + 20)
        .attr("text-anchor", "middle")
        .attr("font-family", "sans-serif")
        .style("font-size", "16px")
        .style("font-weight", "700")
        .text("Top 5 Rating Distribution");

    let legend = svg.selectAll(".legend")
        .data(top5Data.map(d => d.rating))
        .enter()
        .append("g")
        .attr("class", "legend")
        .attr("transform", (d, i) => "translate(0," + (i * 20 + height / 2 - 30) + ")");

    legend.append("rect")
        .attr("x", width / 2 - 18)
        .attr("width", 18)
        .attr("height", 18)
        .style("fill", d => color(d));

    legend.append("text")
        .attr("x", width / 2 - 24)
        .attr("y", 9)
        .attr("dy", ".35em")
        .attr("font-family", "sans-serif")
        .style("font-size", "16px")
        .style("font-weight", "500")
        .style("text-anchor", "end")
        .text(d => d);
}

function visualizeTypePieChart(data) {
    let typeCounts = d3.rollup(data, v => v.length, d => d.type);

    let pieData = Array.from(typeCounts, ([type, count]) => ({ type, count }));

    let width = 600;
    let height = 500;
    let radius = Math.min(width, height) / 2.5;

    let color = d3.scaleOrdinal(d3.schemeCategory10);

    let svg = d3.select("body")
        .append("svg")
        .attr("width", width + 100)
        .attr("height", height + 100)
        .append("g")
        .attr("transform", "translate(" + width / 2 + "," + height / 2 + ")");

    let pie = d3.pie()
        .value(d => d.count);

    let arc = d3.arc()
        .outerRadius(radius - 10)
        .innerRadius(0);

    let arcs = svg.selectAll(".arc")
        .data(pie(pieData))
        .enter()
        .append("g")
        .attr("class", "arc");

    arcs.append("path")
        .attr("d", arc)
        .attr("fill", (d, i) => color(i));

    arcs.append("text")
        .attr("transform", d => "translate(" + arc.centroid(d) + ")")
        .attr("dy", ".25em")
        .text(d => `${d.data.type}: ${d.data.count}`)
        .attr("font-family", "sans-serif")
        .style("font-weight", "600")
        .style("text-anchor", "middle");

    svg.append("text")
        .attr("x", 0)
        .attr("y", height / 2 + 20)
        .attr("text-anchor", "middle")
        .attr("font-family", "sans-serif")
        .style("font-size", "16px")
        .style("font-weight", "700")
        .text("Type Distribution");

    let legend = svg.selectAll(".legend")
        .data(pieData.map(d => d.type))
        .enter()
        .append("g")
        .attr("class", "legend")
        .attr("transform", (d, i) => "translate(0," + (i * 20 + height / 2 - 30) + ")");

    legend.append("rect")
        .attr("x", width / 2 - 18)
        .attr("width", 18)
        .attr("height", 18)
        .style("fill", (d, i) => color(i));

    legend.append("text")
        .attr("x", width / 2 - 24)
        .attr("y", 9)
        .attr("dy", ".35em")
        .attr("font-family", "sans-serif")
        .style("font-size", "16px")
        .style("font-weight", "500")
        .style("text-anchor", "end")
        .text(d => d);
}

function visualizeDurationPieChart(data) {

    let durationCounts = d3.rollup(data, v => v.length, d => d.duration);

    let pieData = Array.from(durationCounts, ([duration, count]) => ({ duration, count }));

    pieData.sort((a, b) => b.count - a.count);

    let top5Data = pieData.slice(0, 5);
    let othersCount = d3.sum(pieData.slice(5), d => d.count);
    top5Data.push({ duration: "Others", count: othersCount });

    let totalCount = d3.sum(top5Data, d => d.count);
    top5Data.forEach(d => {
        d.percentage = (d.count / totalCount) * 100;
    });

    let width = 700;
    let height = 500;
    let radius = Math.min(width, height) / 2.5;

    let color = d3.scaleOrdinal(d3.schemeCategory10);

    let svg = d3.select("body")
        .append("svg")
        .attr("width", width + 100)
        .attr("height", height + 100)
        .append("g")
        .attr("transform", "translate(" + width / 2 + "," + height / 2 + ")");

    let pie = d3.pie()
        .value(d => d.percentage);

    let arc = d3.arc()
        .outerRadius(radius - 10)
        .innerRadius(0);

    let arcs = svg.selectAll(".arc")
        .data(pie(top5Data))
        .enter()
        .append("g")
        .attr("class", "arc");

    arcs.append("path")
        .attr("d", arc)
        .attr("fill", d => color(d.data.duration));

    svg.append("text")
        .attr("x", 0)
        .attr("y", height / 2 + 20)
        .attr("text-anchor", "middle")
        .attr("font-family", "sans-serif")
        .style("font-size", "16px")
        .style("font-weight", "700")
        .text("Top 5 Duration Distribution");

    let legend = svg.selectAll(".legend")
        .data(top5Data)
        .enter()
        .append("g")
        .attr("class", "legend")
        .attr("transform", (d, i) => "translate(0," + (i * 20 + height / 2 - 30) + ")");

    legend.append("rect")
        .attr("x", width / 2 - 18)
        .attr("width", 18)
        .attr("height", 18)
        .style("fill", d => color(d.duration));

    legend.append("text")
        .attr("x", width / 2 - 24)
        .attr("y", 9)
        .attr("dy", ".35em")
        .attr("font-family", "sans-serif")
        .style("font-size", "16px")
        .style("font-weight", "500")
        .style("text-anchor", "end")
        .text(d => `${d.duration} (${d.percentage.toFixed(1)}%)`);
}

function visualizeListedInPieChart(data) {

let listedInCounts = d3.rollup(data, v => v.length, d => d.listed_in);

let pieData = Array.from(listedInCounts, ([category, count]) => ({ category, count }));

pieData.sort((a, b) => b.count - a.count);

let top5Data = pieData.slice(0, 5);
let othersCount = d3.sum(pieData.slice(5), d => d.count);
top5Data.push({ category: "Others", count: othersCount });

let totalCount = d3.sum(top5Data, d => d.count);
top5Data.forEach(d => {
    d.percentage = (d.count / totalCount) * 100;
});

let width = 700;
let height = 500;
let radius = Math.min(width, height) / 2.5;

let color = d3.scaleOrdinal(d3.schemeCategory10);

let svg = d3.select("body")
    .append("svg")
    .attr("width", width + 100)
    .attr("height", height + 100)
    .append("g")
    .attr("transform", "translate(" + width / 2 + "," + height / 2 + ")");

let pie = d3.pie()
    .value(d => d.percentage);

let arc = d3.arc()
    .outerRadius(radius - 10)
    .innerRadius(0);

let arcs = svg.selectAll(".arc")
    .data(pie(top5Data))
    .enter()
    .append("g")
    .attr("class", "arc");

arcs.append("path")
    .attr("d", arc)
    .attr("fill", d => color(d.data.category));

arcs.append("text")
    .attr("transform", d => "translate(" + arc.centroid(d) + ")")
    .attr("dy", ".25em")
    .text(d => `${d.data.percentage.toFixed(1)}%`)
    .attr("font-family", "sans-serif")
    .style("font-weight", "600")
    .style("font-size", "12")
    .style("text-anchor", "middle");

let legend = svg.selectAll(".legend")
    .data(top5Data.map(d => d.category))
    .enter()
    .append("g")
    .attr("class", "legend")
    .attr("transform", (d, i) => "translate(0," + (i * 25 + height / 2 - 40) + ")");

legend.append("rect")
    .attr("x", width / 2 +80)
    .attr("y", -48)
    .attr("width", 18)
    .attr("height", 18)
    .style("fill", d => color(d));

legend.append("text")
    .attr("x", width / 2 + 70)
    .attr("y", -40)
    .attr("dy", ".35em")
    .attr("font-family", "sans-serif")
    .style("font-size", "16px")
    .style("font-weight", "500")
    .style("text-anchor", "end")
    .text(d => d);

svg.append("text")
    .attr("x", 0)
    .attr("y", height / 2 + 20)
    .attr("text-anchor", "middle")
    .attr("font-family", "sans-serif")
    .style("font-size", "16px")
    .style("font-weight", "700")
    .text("Top 5 Listed In Categories Distribution");
}

function visualizeReleaseYearCountsLineChart(data) {
    let margin = { top: 20, right: 30, bottom: 100, left: 60 },
        width = 800 - margin.left - margin.right,
        height = 400 ;

    let svg = d3.select("body")
        .append("svg")
        .attr("width", width + margin.left + margin.right)
        .attr("height", height + margin.top + 80)
        .append("g")
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

    let last20YearsData = data.filter(d => d.release_year >= 2005);

    last20YearsData.forEach(d => {
        d.release_year = +d.release_year; // Convert to number
    });

    let years = Array.from(new Set(last20YearsData.map(d => d.release_year))).sort((a, b) => b - a);

    let yearCounts = years.map(year => {
        return {
            year: year,
            title_count: last20YearsData.filter(d => d.release_year === year).length
        };
    });

    let xScale = d3.scaleBand()
        .domain(years.map(String)) 
        .range([0, width])
        .padding(0.1);

    let maxTitleCount = d3.max(yearCounts, d => d.title_count);
    let yAxisPadding = 30; 

    let yScale = d3.scaleLinear()
        .domain([0, maxTitleCount + yAxisPadding])
        .range([height, 0]);

    let line = d3.line()
        .x(d => xScale(String(d.year)) + xScale.bandwidth() / 2) 
        .y(d => yScale(d.title_count));


    svg.append("path")
        .datum(yearCounts)
        .attr("fill", "none")
        .attr("stroke", "steelblue")
        .attr("stroke-linejoin", "round")
        .attr("stroke-linecap", "round")
        .attr("stroke-width", 2)
        .attr("d", line);

        svg.selectAll(".dot")
            .data(yearCounts)
            .enter().append("circle")
            .attr("class", "dot")
            .attr("cx", d => xScale(String(d.year)) + xScale.bandwidth() / 2) 
            .attr("cy", d => yScale(d.title_count))
            .attr("r", 5)
            .on("mouseover", (event, d) => {
                tooltip.transition()
                    .duration(200)
                    .style("opacity", .9);
                tooltip.html(`<strong>${d.title_count} titles</strong> in ${d.year}`)
                    .style("left", (event.pageX) + "px")
                    .style("top", (event.pageY - 28) + "px");
            })
            .on("mouseout", d => {
                tooltip.transition()
                    .duration(500)
                    .style("opacity", 0);
            });

    svg.selectAll(".dot-label")
        .data(yearCounts)
        .enter().append("text")
        .attr("class", "dot-label")
        .attr("x", d => xScale(String(d.year)) + xScale.bandwidth() / 2) 
        .attr("y", d => yScale(d.title_count) - 10)
        .text(d => d.title_count)
        .attr("text-anchor", "middle")
        .attr("font-family", "sans-serif")
        .style("font-size", "14px")
        .style("font-weight", "600");

    svg.append("g")
        .attr("transform", "translate(0," + height + ")")
        .call(d3.axisBottom(xScale))
        .selectAll("text")
        .attr("transform", "rotate(-45)")
        .style("text-anchor", "end")
        .style("font-size", "14px")
        .attr("font-weight", 700);

    svg.append("g")
        .call(d3.axisLeft(yScale))
        .selectAll("text")
        .style("font-size", "14px")
        .attr("font-weight", 700);

    svg.append("text")
        .attr("x", width / 2)
        .attr("y", height + 70 )
        .attr("text-anchor", "middle")
        .attr("font-family", "sans-serif")
        .style("font-size", "16px")
        .style("font-weight", "700")
        .text("Number of Titles Over the Last 20 Years");

    let tooltip = d3.select("body")
        .append("div")
        .attr("class", "tooltip")
        .style("opacity", 0)
        .style("position", "absolute")
        .style("background", "#f4f4f4")
        .style("padding", "10px")
        .style("border", "1px solid #ccc")
        .style("border-radius", "5px")
        .style("pointer-events", "none");
}

function visualizeReleaseYearCountsListedInLineChart(data) {
    let margin = { top: 20, right: 30, bottom: 80, left: 60 },
        width = 800 - margin.left - margin.right,
        height = 400;

    let svg = d3.select("body")
        .append("svg")
        .attr("width", width + margin.left + margin.right)
        .attr("height", height + margin.top + margin.bottom)
        .append("g")
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

    let last20YearsData = data.filter(d => d.release_year >= 2005);

    last20YearsData.forEach(d => {
        d.release_year = +d.release_year;
    });

    let years = Array.from(new Set(last20YearsData.map(d => d.release_year))).sort((a, b) => b - a);

    let listedInCounts = {};

    last20YearsData.forEach(d => {
        let listedInValues = d.listed_in.split(/\s*,\s*/);

        listedInValues.forEach(listedIn => {
            if (!listedInCounts[listedIn]) {
                listedInCounts[listedIn] = {
                    years: {}
                };
            }

            if (!listedInCounts[listedIn].years[d.release_year]) {
                listedInCounts[listedIn].years[d.release_year] = 1;
            } else {
                listedInCounts[listedIn].years[d.release_year]++;
            }
        });
    });

    let sortedListedIn = Object.keys(listedInCounts)
        .sort((a, b) => d3.sum(Object.values(listedInCounts[a].years)) - d3.sum(Object.values(listedInCounts[b].years)))
        .reverse();

    let top5ListedIn = sortedListedIn.slice(0, 5);

    let xScale = d3.scaleBand()
        .domain(years.map(String)) 
        .range([0, width])
        .padding(0.1);

    let maxTitleCount = d3.max(top5ListedIn.map(d => d3.max(Object.values(listedInCounts[d].years))));
    let yAxisPadding = 30;

    let yScale = d3.scaleLinear()
        .domain([0, maxTitleCount + yAxisPadding])
        .range([height, 0]);

    let colorScale = d3.scaleOrdinal(d3.schemeCategory10);

    let line = d3.line()
        .x(d => xScale(String(d.year)) + xScale.bandwidth() / 2)
        .y(d => yScale(d.value));

    svg.selectAll(".line")
        .data(top5ListedIn)
        .enter()
        .append("path")
        .attr("class", "line")
        .attr("fill", "none")
        .attr("stroke", d => colorScale(d))
        .attr("stroke-width", 2)
        .attr("d", d => line(Object.entries(listedInCounts[d].years).map(([year, count]) => ({ year: +year, value: count }))));

    svg.selectAll(".dot")
        .data(top5ListedIn)
        .enter()
        .append("g")
        .selectAll(".dot")
        .data(d => years.map(year => ({ year, value: listedInCounts[d].years[year] || 0 })))
        .enter().append("circle")
        .attr("class", "dot")
        .attr("cx", d => xScale(String(d.year)) + xScale.bandwidth() / 2)
        .attr("cy", d => yScale(d.value))
        .attr("r", 5)
        .on("mouseover", (event, d) => {
            tooltip.transition()
                .duration(200)
                .style("opacity", .9);
            tooltip.html(`<strong>${d.value} titles</strong> in ${d.year} - ${d3.select(event.target.parentNode).datum()}`)
                .style("left", (event.pageX) + "px")
                .style("top", (event.pageY - 28) + "px");
        })
        .on("mouseout", d => {
            tooltip.transition()
                .duration(500)
                .style("opacity", 0);
        });

    svg.selectAll(".dot-label")
        .data(top5ListedIn)
        .enter()
        .append("g")
        .selectAll(".dot-label")
        .data(d => years.map(year => ({ year, value: listedInCounts[d].years[year] || 0 })))
        .enter().append("text")
        .attr("class", "dot-label")
        .attr("x", d => xScale(String(d.year)) + xScale.bandwidth() / 2)
        .attr("y", d => yScale(d.value) - 10)
        .text(d => d.value)
        .attr("text-anchor", "middle")
        .attr("font-family", "sans-serif")
        .style("font-size", "14px")
        .style("font-weight", "600");

    svg.append("g")
        .attr("transform", "translate(0," + height + ")")
        .call(d3.axisBottom(xScale))
        .selectAll("text")
        .attr("transform", "rotate(-45)")
        .style("text-anchor", "end")
        .style("font-size", "14px")
        .attr("font-weight", 700);

    svg.append("g")
        .call(d3.axisLeft(yScale))
        .selectAll("text")
        .style("font-size", "14px")
        .attr("font-weight", 700);

    let legend = svg.append("g")
        .attr("class", "legend")
        .attr("transform", "translate(" + (width - 200) + ",0)");

    legend.selectAll("rect")
        .data(top5ListedIn)
        .enter()
        .append("rect")
        .attr("x", 0)
        .attr("y", (d, i) => i * 20)
        .attr("width", 18)
        .attr("height", 18)
        .attr("fill", d => colorScale(d));

    legend.selectAll("text")
        .data(top5ListedIn)
        .enter()
        .append("text")
        .attr("x", 25)
        .attr("y", (d, i) => i * 20 + 12)
        .text(d => d)
        .attr("font-family", "sans-serif")
        .style("font-size", "14px")
        .style("font-weight", "600");

    svg.append("text")
        .attr("x", width / 2)
        .attr("y", height + margin.bottom)
        .attr("text-anchor", "middle")
        .attr("font-family", "sans-serif")
        .style("font-size", "16px")
        .style("font-weight", "700")
        .text("Number of Titles by Listed In Over the Last 20 Years");

    let tooltip = d3.select("body")
        .append("div")
        .attr("class", "tooltip")
        .style("opacity", 0)
        .style("position", "absolute")
        .style("background", "#f4f4f4")
        .style("padding", "10px")
        .style("border", "1px solid #ccc")
        .style("border-radius", "5px")
        .style("pointer-events", "none");
}


        const width = 1300;
        const height = 700;
        const colorScale = d3.scaleOrdinal(d3.schemeCategory10);

        const svg = d3.select("body")
                        .append("svg")
                        .attr("width", width)
                        .attr("height", height);
            
const createTreemap = (data, category, genre, rating)=>{ 

        const tooltip = d3.select("body").append("div")
                                .attr("class", "tooltip")
                                .style("opacity", 0)
                                .style("position", "absolute")
                                .style("padding", "4px")
                                .style("background", "lightsteelblue")
                                .style("border", "solid")
                                .style("border-width", "1px")
                                .style("border-radius", "5px")
                                .style("pointer-events", "none");

        tooltip.style("opacity", 0);

        svg.selectAll("*").remove();

        let processedData;

        if (category && genre && rating) {

            let filteredData = data.filter(d => d.type === category && d.listed_in.includes(genre) && d.rating === rating);
            console.log("Filtered Data for rating:", filteredData); 

            if (filteredData.length > 0) {
            let randomTitles = d3.shuffle(filteredData).slice(0, 10);
            console.log("Random Titles:", randomTitles); 
            processedData = randomTitles.map(d => ({ name: d.title, value: 1 }));
            } else {
            console.error("No data found for this rating:", rating);
            return; 
            }
        } else if (category && genre) {
            let filteredData = data.filter(d => d.type === category && d.listed_in.includes(genre));
            processedData = Array.from(d3.rollup(filteredData, v => v.length, d => d.rating), ([name, value]) => ({ name, value }));
        } else if (category) {
            let filteredData = data.filter(d => d.type === category).map(d => ({
                ...d,
                genres: d.listed_in.split(', ')
            })).flatMap(d => d.genres.map(genre => ({
                type: d.type,
                genre: genre
            })));
            processedData = Array.from(d3.rollup(filteredData, v => v.length, d => d.genre), ([name, value]) => ({ name, value }));
            } else {
            processedData = Array.from(d3.rollup(data, v => v.length, d => d.type), ([name, value]) => ({ name, value }));
        }

        const root = d3.hierarchy({children: processedData})
            .sum(d => d.value);

        d3.treemap()
            .size([width, height])
            .padding(2)(root);

        

            svg.on("click", () => console.log("SVG clicked"));

            function mouseover(event, d) {
                let content;

                if (category && genre && rating && d.data.name) {
                
                    let titleData = data.find(item => item.title === d.data.name && item.type === category && item.listed_in.includes(genre) && item.rating === rating);
                    if (titleData) {
                        content = `Title: ${titleData.title}<br>Director: ${titleData.director}<br>Description: ${titleData.description}`;
                    } else {
                        content = "No additional information available";
                    }
                } else {
                    
                    content = "Category: " + d.data.name + "<br>Count: " + d.value;
                }

                tooltip.html(content)
                        .style("left", (event.pageX) + "px")
                        .style("top", (event.pageY) + "px")
                        .transition()
                        .duration(200)
                        .style("opacity", 0.9);
            }

            function mouseout(event, d) {
                tooltip.transition()
                    .duration(500)
                    .style("opacity", 0);
            }

        const leaf = svg.selectAll("g")
            .data(root.leaves())
            .enter().append("g")
            .attr("transform", d => `translate(${d.x0},${d.y0})`);

        leaf.append("rect")
            .attr("class", "rect-border")
            .attr("width", d => d.x1 - d.x0)
            .attr("height", d => d.y1 - d.y0)
            .attr("fill", d => colorScale(d.data.name))
            .style("fill-opacity", 0.7) 
            .attr("stroke", "none");

        leaf.append("rect")
            .attr("class", "rect")
            .attr("width", d => d.x1 - d.x0 - 4) 
            .attr("height", d => d.y1 - d.y0 - 4) 
            .attr("fill", d => colorScale(d.data.name))
            .style("fill-opacity", 0.5) 
            .attr("x", 2) 
            .attr("y", 2) 
            .attr("stroke", d => colorScale(d.data.name)) 
            .attr("stroke-width", "15") 
            .on("mouseover", mouseover)
            .on("mouseout", mouseout)
            .on("click", (event, d) => {
                tooltip.transition().duration(0).style("opacity", 0);

                        if (category && genre && !rating) {
                        
                            createTreemap(data, category, genre, d.data.name);
                        } else if (category && !genre) {
                            
                            createTreemap(data, category, d.data.name);
                        } else if (!category) {
                            
                            createTreemap(data, d.data.name);
                        }
                    });

        leaf.append("text")
                .attr("class", "label")
                .attr("x", d => (d.x1 - d.x0) / 2)
                .attr("y", d => (d.y1 - d.y0) / 2)
                .attr("text-anchor", "middle") 
                .attr("alignment-baseline", "middle")
                .style("fill", "white") 
                .text(d => d.data.name);


        d3.select(".back-button").remove();

        if (category) {
            let backButton = svg.append("g")
                .attr("class", "back-button")
                .style("cursor", "pointer") 
                .on("click", () => {
                    tooltip.style("opacity", 0);
                    createTreemap(data);
                });

            backButton.append("rect")
                .attr("x", width - 40) 
                .attr("y", 10)
                .attr("width", 30)
                .attr("height", 30)
                .attr("fill", "#C8A2C8") 
                .attr("rx", 15) 
                .attr("ry", 15); 

            backButton.append("text")
                .attr("x", width - 25) 
                .attr("y", 30) 
                .text("â†‘") 
                .attr("fill", "white") 
                .attr("text-anchor", "middle")
                .attr("alignment-baseline", "middle")
                .attr("font-size", "20px"); 
        }
 };

    const fetchGeoJSON = async () => {
        try {
            const response = await fetch("countries.geo.json"); 
            const data = await response.json();
            console.log("Loaded GeoJSON data:", data);
            return data;
        } catch (error) {
            console.error("Error loading GeoJSON:", error);
            throw error; 
        }
    };

    const mergeData = (geoData, netflixData) => {

        const netflixDataByCountry = d3.rollup(netflixData, v => ({
            titleCount: v.length,
            topListedIn: getTopListedIn(v),
            categories: [...new Set(v.flatMap(d => d.listed_in.split(', ')))]
        }), d => d.country);

        geoData.features.forEach(feature => {
            const countryName = feature.properties.name;
            const countryData = netflixDataByCountry.get(countryName);
            feature.properties.netflixData = countryData || { titleCount: 0, topListedIn: '', categories: [] };
        });

        return geoData;
    };

    function getTopListedIn(data) {
        const listedInCounts = d3.rollup(data.flatMap(d => d.listed_in.split(', ')), v => v.length, d => d);
        const sortedListedIn = Array.from(listedInCounts.entries())
            .sort((a, b) => b[1] - a[1]);

    return sortedListedIn.length > 0 ? sortedListedIn[0][0] : '';
}

function visualizeChoroplethMap(mergedData) {
    const width = 800;
    const height = 700;
    const margin = { top: 20, right: 20, bottom: 30, left: 20 };


    const svgMap = d3.select("body")
        .append("svg")
        .attr("class", "map")
        .attr("width", width + margin.left + margin.right)
        .attr("height", height + margin.top + margin.bottom);

        d3.select("body")
        .append("div")
        .attr("class", "chart-title")
        .style("text-align", "center")
        .style("font-size", "18px")
        .style("font-family", "sans-serif")
        .style("font-weight", "bold")
        .text("Netflix Titles Choropleth Map");

    const projection = d3.geoMercator()
                            .scale(150) 
                            .translate([width / 2, height / 2]);

    const path = d3.geoPath().projection(projection);

    const uniqueCategories = Array.from(new Set(mergedData.features.map(d => d.properties.netflixData.topListedIn)));
    const categoryColorScale = d3.scaleOrdinal()
        .domain(uniqueCategories)
        .range(['#1f78b4', '#33a02c', '#e31a1c', '#ff7f00', '#6a3d9a', '#b15928', '#a6cee3', '#b2df8a', '#fb9a99', '#fdbf6f']);

    const maxTitleCount = d3.max(mergedData.features, d => d.properties.netflixData.titleCount);
    const opacityScale = d3.scaleLinear()
        .domain([0, maxTitleCount])
        .range([0.5, 1]);

        
    svgMap.selectAll("path")
        .data(mergedData.features)
        .enter()
        .append("path")
        .attr("d", path)
        .attr("fill", d => {
            const topListedIn = d.properties.netflixData.topListedIn;
            const titleCount = d.properties.netflixData.titleCount;
            const categoryColor = topListedIn ? categoryColorScale(topListedIn) : "gray";
            const opacity = titleCount ? opacityScale(titleCount) : 0.5; 

            return `rgba(${d3.color(categoryColor).r}, ${d3.color(categoryColor).g}, ${d3.color(categoryColor).b}, ${opacity})`;
        })
        .attr("stroke", "white")
        .attr("stroke-width", 0.5) 
        .on("mouseover", (event, d) => {
            const titleCount = d.properties.netflixData.titleCount;
            const topListedIn = d.properties.netflixData.topListedIn;
            const tooltipContent = titleCount ?
                `Country: ${d.properties.name}<br>Title Count: ${titleCount}<br>Top Listed In: ${topListedIn || 'N/A'}` :
                `Country: ${d.properties.name}<br>No data available`;

            tooltip.html(tooltipContent)
                .style("left", (event.pageX) + 'px')
                .style("top", (event.pageY - 28) + 'px')
                .transition()
                .duration(200)
                .style("opacity", 0.9);
        })
        .on("mouseout", () => {
            tooltip.transition()
                .duration(500)
                .style("opacity", 0);
        })
        .on("error", (event, d) => {
            console.error("Error in drawing path:", event);
        });
    }
        const tooltip = d3.select("body").append("div")
            .attr("class", "tooltipMap")
            .style("opacity", 0)
            .style("position", "absolute")
            .style("padding", "4px")
            .style("background", "lightsteelblue")
            .style("border", "solid")
            .style("border-width", "1px")
            .style("border-radius", "5px")
            .style("z-index", 9999)
            .style("pointer-events", "none");


NetflixData((data) => {
    // console.log(data)

    visualizeDurationCountsHistogram(data);
    visualizeReleaseYearCountsHistogram(data);
    visualizeDateAddedCountsHistogram(data);
    visualizeRatingCountsHistogram(data);
    visualizeTopDirectorsHistogram(data);
    visualizeRatingPieChart(data);
    visualizeTypePieChart(data);
    visualizeDurationPieChart(data);
    visualizeListedInPieChart(data);
    visualizeReleaseYearCountsLineChart(data);
    visualizeReleaseYearCountsListedInLineChart(data);
    createTreemap(data);

    Promise.all([fetchGeoJSON(), new Promise(resolve => NetflixData(resolve))])
        .then(([geoData, netflixData]) => {
            const mergedData = mergeData(geoData, netflixData);
            console.log(mergedData);
            visualizeChoroplethMap(mergedData);
        })
        .catch(error => {
            console.error('Error fetching data:', error);
        });

});

    </script>

</body>
</html>